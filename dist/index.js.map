{"version":3,"sources":["../src/useChange.ts","../src/useEntry.ts","../src/useObservable.ts","../src/useObservableList.ts","../src/useObservableMap.ts","../src/useValue.ts"],"sourcesContent":["import type { Observable } from \"@glowhop/observables\";\nimport { useEffect } from \"react\";\n\nexport default function useChange<T, W>(\n\tobservable: Observable<T>,\n\taccessor: (value: T) => W,\n\tdeps: React.DependencyList,\n) {\n\t// const onEffect = useEffectEvent((value: T) => {\n\t//   accessor(value);\n\t// });\n\n\tconst onEffect = (value: T) => {\n\t\taccessor(value);\n\t};\n\n\t// biome-ignore lint/correctness/useExhaustiveDependencies: we want to control deps manually\n\tuseEffect(() => {\n\t\tconst sub = () => {\n\t\t\tonEffect(observable.get());\n\t\t};\n\n\t\tsub();\n\n\t\tconst unsubscribe = observable.subscribe(sub);\n\n\t\treturn () => {\n\t\t\tunsubscribe();\n\t\t};\n\t}, [observable, ...deps]);\n}\n","import type { ObservableList, ObservableMap } from \"@glowhop/observables\";\nimport { type DependencyList, useEffect, useState } from \"react\";\n\nconst OBSERVABLE_MAP_TAG = \"[object ObservableMap]\";\n\nfunction isObservableMap<K extends string | number | bigint, T>(\n\tobservable: ObservableList<T> | ObservableMap<K, T>,\n): observable is ObservableMap<K, T> {\n\t// ObservableList and ObservableMap share the same surface API; Symbol.toStringTag is the safest runtime discriminator.\n\treturn Object.prototype.toString.call(observable) === OBSERVABLE_MAP_TAG;\n}\n\ninterface UseEntry {\n\t<T>(observable: ObservableList<T>, index: number): T | undefined;\n\t<K extends string | number | bigint, T>(observable: ObservableMap<K, T>, key: K): T | undefined;\n\t<T, W = T | undefined>(\n\t\tobservable: ObservableList<T>,\n\t\tindex: number,\n\t\taccessor: (value: T | undefined) => W,\n\t\tdeps?: DependencyList,\n\t): W;\n\t<K extends string | number | bigint, T, W = T | undefined>(\n\t\tobservable: ObservableMap<K, T>,\n\t\tkey: K,\n\t\taccessor: (value: T | undefined) => W,\n\t\tdeps?: DependencyList,\n\t): W;\n}\n\nconst useEntry: UseEntry = <T, K extends string | number | bigint = number, W = T | undefined>(\n\tobservable: ObservableList<T> | ObservableMap<K, T>,\n\tindex: K | number,\n\taccessor?: (value: T | undefined) => W,\n\tdeps?: DependencyList,\n) => {\n\t// Normalise the projected value so list and map branches share the same update logic.\n\tconst project = (entry: T | undefined): W => {\n\t\treturn accessor ? accessor(entry) : (entry as unknown as W);\n\t};\n\n\tconst readSnapshot = () => {\n\t\tif (isObservableMap(observable)) {\n\t\t\treturn project(observable.getEntry(index as K));\n\t\t}\n\t\treturn project(observable.getEntry(index as number));\n\t};\n\n\tconst [value, setValue] = useState<W>(readSnapshot);\n\n\t// Subscribe to either the indexed list entry or the keyed map entry and mirror updates into local state.\n\t// biome-ignore lint/correctness/useExhaustiveDependencies: accessor participation is managed via deps\n\tuseEffect(() => {\n\t\tconst handleEntry = (entry: T | undefined) => {\n\t\t\tsetValue(project(entry));\n\t\t};\n\n\t\tif (isObservableMap(observable)) {\n\t\t\tconst key = index as K;\n\n\t\t\thandleEntry(observable.getEntry(key));\n\t\t\tconst unsubscribe = observable.subscribeEntry(key, handleEntry);\n\n\t\t\treturn () => {\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t}\n\n\t\tconst idx = index as number;\n\n\t\thandleEntry(observable.getEntry(idx));\n\t\tconst unsubscribe = observable.subscribeEntry(idx, handleEntry);\n\n\t\treturn () => {\n\t\t\tunsubscribe();\n\t\t};\n\t}, [observable, index, ...(deps ?? [])]);\n\n\treturn value;\n};\n\nexport default useEntry;\n","import { Observable } from \"@glowhop/observables\";\nimport { useState } from \"react\";\n\nexport default function useObservable<T>(initialValue: T): Observable<T> {\n    return useState(() => new Observable(initialValue))[0];\n}","import { ObservableList } from \"@glowhop/observables\";\nimport { useState } from \"react\";\n\nexport default function useObservableList<T>(initialValue: T[]): ObservableList<T> {\n    return useState(() => new ObservableList(initialValue))[0];\n}","import { ObservableMap } from \"@glowhop/observables\";\nimport { useState } from \"react\";\n\nexport default function useObservableMap<K extends string | number | bigint, T>(initialValue: Map<K, T> | [K, T][]): ObservableMap<K, T> {\n    return useState(() => new ObservableMap<K, T>(initialValue))[0];\n}","import { ObservableMap, type Observable } from \"@glowhop/observables\";\nimport { useEffect, useState } from \"react\";\n\ninterface UseValue {\n\t<T>(observable: Observable<T>): T;\n\t<T, W = T>(\n\t\tobservable: Observable<T>,\n\t\taccessor?: (value: T) => W,\n\t\tdeps?: React.DependencyList,\n\t): W;\n}\n\nconst useValue: UseValue = <T, W = T>(\n\tobservable: Observable<T>,\n\taccessor?: (value: T) => W,\n\tdeps?: React.DependencyList,\n) => {\n\t// Accessors let callers derive a slice without forcing consumers to handle optional chaining everywhere.\n\tconst project = (newValue: T) => {\n\t\treturn accessor ? accessor(newValue) : (newValue as unknown as W);\n\t};\n\n\tconst [value, setValue] = useState(() => project(observable.get()));\n\n\t// biome-ignore lint/correctness/useExhaustiveDependencies: accessor stability is delegated to deps\n\tuseEffect(() => {\n\t\tconst handleValue = (next: T) => {\n\t\t\tsetValue(project(next));\n\t\t};\n\n\t\t// Replay the latest snapshot so the hook responds immediately even if no emission happens.\n\t\thandleValue(observable.get());\n\t\tconst unsubscribe = observable.subscribe(handleValue);\n\n\t\treturn () => {\n\t\t\tunsubscribe();\n\t\t};\n\t}, [observable, ...(deps ?? [])]);\n\n\treturn value;\n};\n\nexport default useValue;"],"mappings":"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","names":["useEffect","unsubscribe","useState","useState","useState","useEffect","useState"]}